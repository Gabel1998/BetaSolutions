package com.example.betasolutions.service;

// ProjectServiceIntegrationTests.java
import com.example.betasolutions.config.H2TestConfig;
import com.example.betasolutions.model.Project;
import com.example.betasolutions.service.ProjectService;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.annotation.Rollback;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.context.jdbc.SqlConfig;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.AssertionsForClassTypes.withinPercentage;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.springframework.test.context.jdbc.SqlConfig.ErrorMode.CONTINUE_ON_ERROR;

// Starts the entire Spring Boot application in test context
@SpringBootTest
@ActiveProfiles("test")
@Import(H2TestConfig.class)
// Disable referential integrity to allow dropping tables without foreign key errors
@Sql(statements = "SET REFERENTIAL_INTEGRITY FALSE")
// Runs the SQL script located in src/test/resources before each test method & continue on errors (e.g., drops of non-existing tables)
@Sql(scripts = "classpath:h2init.sql", config = @SqlConfig(errorMode = CONTINUE_ON_ERROR))
// Re-enables referential integrity after the script runs
@Sql(statements = "SET REFERENTIAL_INTEGRITY TRUE")
// Ensures the context is reset after each test (deletes everything in H2)
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
// Ensures all test methods run in a transaction
@Transactional
// And that the transaction is rolled back after the test (so data remains clean for the next test)
@Rollback(true)
public class ProjectServiceIntegrationTest {

    @Autowired
    private ProjectService projectService;

    @Test
//  Calculate total actual and estimated hours for a project
    void testProjectHoursCalculations() {
        int pid = 1000;
        double actual = projectService.getTotalActualHoursForProject(pid);
        double estimated = projectService.getTotalEstimatedHoursForProject(pid);
        assertThat(actual).isEqualTo(85.5);
        assertThat(estimated).isEqualTo(80.0);
    }

    @Test
//  Calculate project hours for multiple projects
    void testCalculateProjectHoursMap() {
        Map<Integer, Map<String, Double>> map = projectService.calculateProjectHoursByProjectIds(Arrays.asList(1000, 1001));
        assertThat(map).containsKeys(1000, 1001);
        assertThat(map.get(1000).get("actualHours")).isEqualTo(85.5);
        assertThat(map.get(1001).get("estimatedHours")).isEqualTo(100.0);
    }

    @Test
//  Adjust estimated hours based on employee efficiency
    void testAdjustEstimatedHours() {
        double adjusted = projectService.adjustEstimatedHoursBasedOnEfficiency(1000);
        assertThat(adjusted).isCloseTo(80.0/1.10, withinPercentage(0.1));
    }

    @Test
//  Create, update and delete a project
    void testCrudProject() {
        // 1) Create a new Project (id is still null here)
        Project toSave = new Project();
        toSave.setName("My Project");
        // … set other fields …

        // 2) Persist it
        projectService.createProject(toSave);

        // 3) Immediately re-load it from the DB so you get the real id
        Project persisted = projectService.getAllProjects().stream()
                .filter(p -> p.getName().equals(toSave.getName()))
                .findFirst()
                .orElseThrow(() -> new AssertionError("Project not found"));

        // 4) Now persisted.getId() is non-null, and you can continue your CRUD assertions:
        assertNotNull(persisted.getId(), "should have been generated by the DB");

        // Update it
        persisted.setDescription("New description");
        projectService.updateProject(persisted);

        // Fetch again and assert the change
        Project updated = projectService.getProjectById(persisted.getId()).get();
        assertEquals("New description", updated.getDescription());

        // … and so on for delete, etc.
    }

    @Test
//  Count workdays between two dates
    void testCountWorkdays() {
        long days = projectService.countWorkdays(
                LocalDate.of(2025,5,12), LocalDate.of(2025,5,16)
        );
        assertThat(days).isEqualTo(5);
    }
}
